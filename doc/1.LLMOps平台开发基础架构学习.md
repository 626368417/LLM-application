# LLMOps 平台开发基础

## 什么是大语言模型

大语言模型（Large Language Model, `LLM`）是基于深度学习的自然语言处理模型，通常使用大量的文本数据进行训练。它们能够理解、生成、翻译、总结和回答自然语言问题。其核心思想是通过对大量语料库的学习，捕捉语言中的规律和结构，从而进行预测和生成

**大语言模型的关键特点**

1. **规模庞大**：

   - **参数数量**：通常拥有数十亿甚至数万亿参数（模型的“记忆单元”），例如`GPT-3`有 1750 亿参数。
   - **训练数据**：使用互联网上的海量文本（如书籍、网页、论文等）进行训练，涵盖多种语言和领域。

2. **通用性**

   - 能够处理多种任务（写作、编程、推理等），而无需针对特定任务专门训练。

   - 通过“提示（prompt）”灵活调整输出，例如输入问题直接生成答案 。

     3.**基于 Transformer 架构**：

   - 依赖 Transformer 神经网络（2017 年提出），擅长捕捉长距离语义关联。

   - 通过自注意力机制（Self-Attention）理解上下文关系 。

## 大语言模型的基础单位

### **token**

它是模型处理文本的最小语义单元。Token 可以是单词、子词、字符，甚至是标点符号或特殊符号。理解 Token 的作用和分词方式，是掌握大语言模型如何学习和生成文本的关键。

**中英文 Token 的差异**

| **语言** | **典型 Token 长度**  | **例子**                         | **特点**                                             |
| :------- | :------------------- | :------------------------------- | :--------------------------------------------------- |
| 英文     | 1 Token ≈ 4 字符     | `"Hello"` → `["Hello"]`          | 长单词拆分（如`"tokenization"→["token","ization"]`） |
| 中文     | 1 Token ≈ 1-2 个汉字 | `"人工智能"` → `["人工","智能"]` | 单字或常见词组为主                                   |

**分词器差异**：

不同模型的分词策略不同（如 GPT-4 与 Claude 的分词方式可能不同），导致同一文本的 Token 数量和切分结果不同

### **模型的工作流程**

**示例：输入到输出流程**

**输入文本**：
`"The capital of France is ______."`
​**​ 处理步骤 ​**​：

1. 分词 → `["The", "capital", "of", "France", "is", "______", "."]`
2. 编码为 Token ID 序列 → `[5, 12, 7, 356, 10, 999, 3]`
3. 模型预测 → 最可能填充 `"Paris"`（对应 Token ID 42）。
4. 解码输出 → `"The capital of France is Paris."`

### 大语言模型的 Token 预测机制

本质上是基于已输入的上下文，计算下一个可能出现的 Token 的概率分布，并从中选择最终输出的过程。最简单的办法就是**基于统计\*\***通过大量数据的统计，找到下一个 Token。

**Token 预测的关键策略**

1. **贪婪搜索（Greedy Search）**

- **机制**：每一步选择概率最高的 Token。

- **优点**：计算速度快，结果确定性强。

- **缺点**：易陷入重复或局部最优（如循环生成 “的的的...”）。

  ```text
  输入：“中国的首都是”
  预测：每一步选最高概率 → “北” → “京” → “。”
  输出：“中国的首都是北京。”
  ```

2. **束搜索（Beam Search）**

- **机制**：保留 k*k* 个候选序列（称为束宽），每步扩展所有候选，仅保留总概率最高的 k*k* 个。
- **优点**：平衡生成质量与多样性，适合需要严谨性的任务（如翻译）。
- **缺点**：计算成本随 k*k* 增大而上升，可能忽略低频但合理的选项。
- **示例**（束宽 k=2*k*=2）：

```text
候选1：“北京”（概率0.7） → 候选1扩展：“北京是”（总概率0.7×0.6=0.42）
候选2：“南京”（概率0.3） → 候选2扩展：“南京曾”（总概率0.3×0.8=0.24）
最终保留总概率最高的候选1。
```

3. **采样（Sampling）**

- **机制**：根据概率分布随机选择 Token，可通过参数调控随机性：

  - **温度（Temperature）**：
    - T→0*T*→0：趋近贪婪搜索（选择最高概率）。
    - T→1*T*→1：保持原始分布。
    - T>1*T*>1：拉平分布，增加多样性（可能降低合理性）。
  - **Top-k 和 Top-p（核采样）**：
    - **Top-k**：仅从概率最高的前 k*k* 个 Token 中采样。
    - **Top-p**：仅从累积概率达 p*p* 的最小 Token 集合中采样（动态调整范围）。

- **优点**：生成结果多样，适合创意任务（如写诗、故事）

  ```tex
  概率分布：北京(0.7)、南京(0.2)、东京(0.1)
  采样结果可能为“南京”（以20%概率选中）。
  ```

### 大语言模型中的训练

1. **数据准备**

首先，需要大量的文本数据作为输入，这些数据通常来自各种来源，如新闻文章、书籍、网页内容等。数据的处理步骤包括：

- **清理数据**：去除无关的字符、HTML 标签、特殊符号等。
- **分词（Tokenization）**：将文本切分成更小的单位（Token），可以是单词、子词、字符等。
- **构建词汇表**：通过分析数据集中的所有 Token，构建模型可以理解的词汇表。

2. **模型架构**

大语言模型通常采用**Transformer**架构，特别是**自注意力机制（Self-Attention）**，以捕捉词与词之间的关系和上下文。Transformer 架构可以分为两种主要结构：

- **自回归模型（如 GPT）**：这种模型使用解码器来预测下一个词，适用于生成任务。
- **自编码模型（如 BERT）**：这种模型使用编码器来学习输入文本的表示，适用于理解任务，如问答、文本分类。

3. **训练过程**

训练的核心步骤如下：

- **前向传播（Forward Pass）**：输入的文本数据被转换为词向量，然后通过模型的各个层进行计算，最终输出每个词的预测结果。
- **损失计算**：通过计算模型的预测结果和真实标签之间的误差（通常是使用**交叉熵损失**），得到损失值。这个损失值衡量了模型预测的准确性。
- **反向传播（Backward Pass）**：利用反向传播算法，计算损失对每个模型参数的梯度，指导模型如何调整参数。
- **参数更新**：根据计算出的梯度，使用优化算法（如**Adam 优化器**）更新模型的参数，使模型逐步减少误差。

4. **迭代训练**

训练是一个循环过程。每次通过数据集后，模型参数会进行调整，通常训练会进行多轮（Epoch）。每轮的训练都会让模型在特定任务上表现得更好。

5. **微调（Fine-tuning）**

大语言模型通常先进行**预训练**，学习语言的基础知识。然后，针对特定任务（如文本分类、问答系统）进行**微调**，使模型更好地适应该任务的要求。

## Agent

### 什么是 Agent

**Agent（智能体）** 是指能够**感知环境、自主决策并采取行动**以实现特定目标的实体。在人工智能领域，Agent 通常指通过算法和模型驱动的程序或系统，能够与环境交互并完成复杂任务

### **Agent 的简单架构图**

以下是基于文本的架构描述（可用工具如 Draw.io、Lucidchart 绘制）：

```
+-------------------+       +-------------------+       +-------------------+
|   环境交互层       |<----->|   决策模块         |<----->|   执行模块         |
| (感知与行动)       |       | (分析、规划、推理) |       | (动作/输出)        |
+-------------------+       +-------------------+       +-------------------+
        ↑                           ↑                           ↑
  [传感器/API]                [规则/模型/LLM]            [机械臂/机器人/软件]
```

#### **1. 环境交互层**

- 感知：通过传感器、摄像头、API 等获取环境数据。
  - 示例：麦克风接收语音指令。
- 行动：执行模块的输出转化为具体动作。
  - 示例：发送邮件、控制机器人移动。

#### **2. 决策模块**

- **输入**：环境数据（如文本、图像）。
- 处理：
  - **规则引擎**：基于预定义逻辑决策（如“如果温度>30℃，则开风扇”）。
  - **机器学习模型**：使用 LLM（如 GPT）生成回答，或强化学习优化策略。
- **输出**：行动方案（如“回复用户：已为您订票”）。

#### **3. 执行模块**

- 将决策转化为物理或数字动作。
  - 示例：机械臂抓取物体、软件调用 API 发送数

### Agent 应用

1. **AI 智能客服**：利用 `LLM` + 企业自有知识库构建的 AI 智能客服机器人

2. **AI 数据分析**：利用 Agent/LLM 参与数据的自动分类、信息提取、数据分析等，建立起各项数据之间的关联。
3. **人工智能即服务（AIaaS**）：百度翻译后端使用神经网络模型来实现将一种语言翻译成另一种语言，需要单独采集数据、训练、部署、开发 API。而在 AIaaS 中，通过限定的预设 Prompt + 规范化输出，企业一分钟就能实现一个翻译 API

## 大模型的局限性

1. 无法获取实时信息。(数据时效性:如突发新闻)
2. 无法基于企业内部信息进行问答。(GPT 模型的训练资料都来源于互联网公开资料集)
3. 缺乏真正的理解能力。对复杂逻辑推理（如数学证明、多步骤规划）能力有限
4. 幻觉（Hallucination）：模型可能生成看似合理但**不符合事实**的内容（如虚构数据、错误结论）回答“量子计算的原理”时，混入未经验证的理论。

## LLM 在软件开发中的单点提效

**1.** **\*\*智能代码提示\*\***：能根据对应的注释生成对应的代码。

**2.** **\*\*SQL 语句智能生成\*\***：将自然语言转换成结构化的 SQL 语句。

**3.** **\*\*静态代码检查与自动修复\*\***：查看程序错误并给出解决方案。

**4.** **\*\*单元/接口测试代码生成\*\***：根据对应的代码生成单元测试代码。

**5.** **\*\*代码评审和重构\*\***：审核对应代码的功能。

**6.** **\*\*失败用例自动分析与归因\*\***：根据程序抛出的错误进行总结分析。

**7.** **\*\*重复代码检查\*\***：自动检查代码中可复用的部分。

**8.** **\*\*跨端代码快速转换\*\***：快速将同一个功能的代码转换成另外一种代码，例如 Vue.js 转 React。

**9.** **\*\*代码注释生成\*\***：快速为每一行代码添加上注释。

**\*\*更精准的技术问答\*\***：代替 Google 实现更高效率、更精确的问答。速获得与自己问题相关的资源，避免了无效的查找和搜索。

在正式聊 AI 编程对程序员的影响前，我们先来看下按照特定规则划分的 AI 自动化编程的 5 个等级：

**1.** **\*\*C1\*\***：基于当前代码自动补全。

**2.** **\*\*C2\*\***：编写代码时 AI 可以预测下一行代码。

**3.** **\*\*C3\*\***：基于自然语言生成代码与编程语言的翻译。

**4.** **\*\*C4\*\***：高度自动化编程包括自然语言生成代码及注释、自动化测试、编程语言互译、代码补全与生成、调试及检查。

**5.** **\*\*C5\*\***：完全自动编程，AI 可以看成是一个任意的软件，甚至无需代码，基于 AI 本身即可提供对应的服务。

如果按照这 5 个等级，目前**\*\*大语言模型位于 C3-C4 的阶段，对于一些简单的项目可以一次性完成，复杂项目仍然无能为力\*\***。

## LLM 应用开发专有名词解释

1. **AIGC-AI 生成内容**：而 ChatGPT 则是 AIGC 在聊天对话场景的一个具体应用。（涵盖文字、图像、视频、音频、游戏、虚拟人等等）
2. **AGI-人工通用智能**：就是一种能够“思考”和“理解”各种问题的智能生命体，就像人类一样。（目前无法实现）

3. **Agent-智能代理/智能体**：一个能够自主感知环境并采取行动的计算实体，其目标是最大化某种预定义的效用或实现特定的目标

4. **Prompt-提示词**：指给定的一段文本或问题，用于引导和启发人工智能模型生成相关的回答或内容。
5. **GPT-生成型预训练变换模型**：GPT 使用 Transformer 模型架构，它由多个编码器-解码器堆叠而成，通过自注意力机制来处理输入序列和生成输出。模型的训练采用了无监督学习的方法，使用大量的文本数据进行预训练，使模型具备了广泛的语言理解和生成能力
6. **Token-文本基础单元**：单元可以是单词、字符、子词或其他语言单位，具体取决于任务和处理方式。

7. **LoRA-插件式微调**：用于对大语言模型进行个性化的特定任务的定制。uLoRA 通过将模型的权重矩阵分解成低秩的相似矩阵，降低了参数空间的复杂性，从而减少微调的计算成本和模型存储要求。
8. **矢量/向量数据库**：矢量数据库可以存储和管理大量的矢量数据，例如图像、视频、音频、文本等，同时提供高效检索功能。矢量数据库通常基于矢量搜索引擎实现
9. **数据蒸馏**：数据蒸馏指将给定的原始大数据集浓缩并生成一个小型数据，使得在小数据集上训练出来的模型与原数据集上训练的模型相似

## LLM 大模型到 AI Agent 的技术演进

### LLM/RAG/Agent 技术演进

| **维度**         | **LLM（大型语言模型）**                     | **RAG（检索增强生成）**                  | **Agent（智能体）**                    |
| :--------------- | :------------------------------------------ | :--------------------------------------- | :------------------------------------- |
| **技术定位**     | 基础文本生成与理解                          | 知识增强型生成                           | 自主决策与行动                         |
| **核心架构**     | - Transformer 自注意力机制 - 千亿级参数模型 | LLM + 检索系统（向量数据库/搜索引擎）    | LLM + 规划器 + 工具调用 + 记忆模块     |
| **关键技术突破** | - GPT-3（2020） - 思维链（2022）            | - REALM（2020） - DPR（2021）            | - ReAct 框架（2022） - AutoGPT（2023） |
| **核心能力**     | - 文本生成 - 零样本推理                     | - 动态知识融合 - 减少幻觉                | - 多步骤规划 - 工具调用与协作          |
| **典型应用场景** | - 聊天机器人 - 代码生成                     | - 知识库问答 - 事实性内容生成            | - 自动化工作流 - 多 Agent 协作系统     |
| **关键挑战**     | - 知识静态性 - 幻觉问题                     | - 检索效率与精度 - 知识碎片整合          | - 复杂任务规划 - 安全可控性            |
| **技术演进方向** | - 多模态融合 - 轻量化（如 Phi-3）           | - 混合检索（语义+关键词） - 实时知识更新 | - 具身智能 - 联邦式多 Agent 协作       |
| **资源消耗**     | 极高（训练/推理成本）                       | 中等（需维护检索系统）                   | 高（实时交互+工具调用）                |
| **代表项目**     | GPT-4、Llama3、PaLM                         | ChatGPT + 联网搜索、Perplexity           | AutoGPT、MetaG                         |

**技术演进关系图解**
LLM（基座能力）
↓
RAG（知识扩展）
↓
Agent（行动升级）
↑
多模态/具身智能（未来融合）

## LLMOps

### 什么是 LLMOps？

**LLMOps（Large Language Model Operations）** 是针对大型语言模型（LLMs，如 GPT、PaLM 等）的全生命周期管理实践，结合了传统 MLOps（机器学习运维）与 LLMs 的独特需求。它涵盖以下核心内容：

1. 模型版本控制
   - 跟踪模型权重、配置和训练数据的变化，支持实验回溯。
2. 自动化部署
   - 优化模型推理性能（如量化、剪枝），支持多环境部署（云、边缘设备）。
3. 持续监控
   - 检测模型性能下降、数据漂移，确保输出安全合规。
4. 协作与复现性
   - 提供团队协作工具，确保实验可复现（如 MLflow 记录超参数）。
5. 资源优化
   - 管理分布式训练、推理的资源分配，降低成本。

**\*\*低门槛创建 AI Agent\*\***

一个 AI Agent 应用涵盖了**\*\*LLM、记忆、工具、Prompt、规划、知识库、执行者\*\***等模块，但每个应用的流程又比较接近，对开发者和非开发者都不友好。

有没有一个平台，能在可视化界面通过鼠标拖拽对应的模块+提示词等内容，就可以让无编程基础的人也可以快速创建一个 AI Agent 应用并调试部署？

在以往这种平台叫做低代码平台，在低代码平台上去拖拽对应的组件，可以快速创建 APP、快速创建小程序、快速创建网站等等。

基于这个概念和想法，于是就有了 LLMOps 这个概念。

**\*\*02. LLMOps 的定义与具体目标\*\***

LLMOps 是一个基于 LLM 的应用程序的生命周期管理平台或者工具，涵盖了**\*\*LLM 应用的开发、部署、配置、运维\*\***。

虽然 LLM 在原型开发中使用起来特别简单，下载 Python 配置相应的接口，就可以便捷和 LLM 进行对话，但是在商业产品中使用 LLM 仍然面临着各种挑战。

LLM 应用开发声明周期包括许多复杂的组件，如**\*\*数据摄取、数据准备、提示工程、模型微调、模型部署、模型监控、工具回调、多 LLM 创联、多 LLM 兼容\*\***等。

在使用 LLMOps 平台之前，基于 LLM 开发应用的过程会非常繁琐，开发者需要自行处理各个阶段的任务，这可能导致效率低下、难以扩展和安全性问题。

LLMOps 对使用者友好，极大降低了企业创建 AI Agent 应用的成本，把复杂的部分留给了 LLMOps 开发者。

两种模式开发 AI 应用流程对比：

1. 不使用 LLMOps：整理需求、Prompt 编写、部署 LLM、对接 LLM 接口、处理应用数据、记录日志、应用工具开发、AI 工作流开发、前后端交互开发、前后端部署。
2. 使用 LLMOps：需求整理、Prompt 编写、上传数据、勾选关联插件、可视化编排工作流、选择 LLM 模型、发布。

### LLMOps 应用有那些

1.`dify`:生成式 AI 应用创新引擎(http://difyai.com/)

### LLMOps 项目需求拆分与设计

#### **整体架构分层**

| 层级       | 组件示例                             | 功能说明                             |
| ---------- | ------------------------------------ | ------------------------------------ |
| **数据层** | 结构化数据、非结构化文档、向量数据库 | 存储训练数据、知识库、用户交互日志   |
| **模型层** | 预训练模型、微调模型、RAG 模块       | 模型训练、优化、版本管理             |
| **服务层** | API 网关、推理引擎、负载均衡器       | 模型部署、请求路由、动态扩缩容       |
| **监控层** | Prometheus、ELK、定制化检测工具      | 性能监控、内容安全审核、用户反馈收集 |
| **治理层** | 权限控制、审计日志、合规检查工具     | 数据隐私保护、模型行为审计           |

**1.应用模块**

1.提示词

       - LLMOps的核心配置在通过不同的Prompt来让LLM实现不同的功能，应用模块添加的提示词均为系统提示词

2.记忆

- 短期记忆：在不超过上下文的情况固定携带最近的 N 条消息短期记忆。
- 长期记忆：长期记忆总结整个对话流程，用一段不超过固定长度的话来进行总结整个对话

  3.技能

- 工具
- 工作流：关联工具或者工作流，在 LLM 需要调用技能才能实现，会自动对应的技能

  4.知识库

- 应用可以关联多个知识库，如果关联了知识库，应用会在每次对话的时候，先查询知识库，然后将知识库检索的文档段一起附加到提示中一起提问。

  5.开场白

- 用户进入应用后自动展示的引导信息，它的主要目的是帮助用户理解应用的用涂。

  6.追问

- 在每次生成回复后，大语言模型生成对应的后续问题建议，和用户后续二次提问提供参考
- 最多支持设置 5 个用户问题建议

  7.推荐问题

- 为应用配置不超过 3 个推进问题，在应用的对话聊天界面，点击推荐问题可以直接使用推荐问题和应用进行对话。

  8.语言

  9.敏感内容审核

- 对用户的输入及 LLM 的输出进行审核，支持使用敏感关键词。

  10.调试对话

- 支持编排页面基于最新的配置信息与应用进行调试对话，校验配置效果，并支持情况对话

**2. 工作流模块**

工作流不可以单独调用，必须整合应用进行使用。工作流将复杂的任务分解成较小的步骤（节点）降低系统复杂度，减少对提示词技术和模型推理的依赖，提高 LLM 应用复杂任务的性能。

**节点**

1.开始：工作流开始节点，可以在开始节点自定义启动工作流的输入变量，每个工作流都需要一个开始节点

2.结束：工作流结束节点每个工作流都执行后都需要至少终止节点，终止节点无法添加其他的节点，工作流程到节点才会输出执行结果

3.大语言模型：调用大语言模型回答问题或者自然语言进行处理。

4.知识库检索：从知识库检索与用户问题相关的文本内容。

5.代码解释器 ：代码解释器在运行 pythone/Nodejs 的窗口，以支持工作流中执行数据转换。支持结构化数据处理，数学计算，拼接数据等

6.条件分支器：允许使用 if/else 将工作流拆分成两个分支，执行不同的工作流程线。

7.变量聚合： 负责整合不同分支/节点的输出，将多个输出字段统一到一起。

8.HTTP 请求：可以访问外部链接的工具。

9.工具：使用内置的工具，或者自定义工具执行流程节点任务的节点

**3.知识库模块**

1. 知识库是文档的集合，一个知识库可以被整体集成到一个应用中作为检索上下文使用。
2. 知识库支持上传两种格式数据：本地文档和 URL 连接在线采集网站数据集成

**4.工具模块**

1.内置工具：LLMOps 内置预设的工具

2.自定义工具：通过特定的规范将 API 编排集成工具

**5.大模型**

1.支持多种 LLM 接入，

2，后端新增接入 LLM，前端通过 API 请求获取对应 LLM 模型。

**6.发布渠道**

1.webApp 模块：将应用发布 LLMops 的 webApp，通过链接即可在访问对应 AI 应用。

2.企业微信号：配置微信企业 ID，将对应的 AI 应用发布到企业微信 号上，实现微信聊天机器人。

3.微信公号：配置对应的开发者 ID，将对应的 AI 应用发布到微信公众号，

**7.广场模块**

1.应用广场：LLMOps 平台内置的内置的预设编排，并且不同的应用进行分类

2.工具广场：

**8.开发 API 模块**：通常对应 api 地址与秘钥，快速外部应用或者企业资源

**9.授权校验模块**：手机登录，微信
